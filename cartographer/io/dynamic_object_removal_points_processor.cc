//
// Created by ubuntu on 20.02.21.
//
#include <cmath>
#include <chrono>
#include <thread>
#include <iomanip>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <vector>

#include "dynamic_object_removal_points_processor.h"

namespace cartographer {
namespace io {
DynamicObjectsRemovalPointsProcessor::RunState DynamicObjectsRemovalPointsProcessor::run_state_ =
    DynamicObjectsRemovalPointsProcessor::RunState::kInitialRun;

void WriteBinaryPlyHeader(const bool has_color, const bool has_intensities,
                          const std::vector<std::string> &comments,
                          const int64 num_points,
                          FileWriter *const file_writer) {
  const std::string color_header = !has_color ? ""
                                              : "property uchar red\n"
                                                "property uchar green\n"
                                                "property uchar blue\n";
  const std::string intensity_header =
      !has_intensities ? "" : "property float intensity\n";
  std::ostringstream stream;
  stream << "ply\n"
         << "format binary_little_endian 1.0\n"
         << "comment generated by Cartographer\n";
  for (const std::string &comment : comments) {
    stream << "comment " << comment << "\n";
  }
  stream << "element vertex " << std::setw(15) << std::setfill('0')
         << num_points << "\n"
         << "property float x\n"
         << "property float y\n"
         << "property float z\n"
         << color_header << intensity_header << "end_header\n";
  const std::string out = stream.str();
  CHECK(file_writer->WriteHeader(out.data(), out.size()));
}

void WriteBinaryPlyPointCoordinate(const Eigen::Vector3f &point,
                                   FileWriter *const file_writer) {
  // TODO(sirver): This ignores endianness.
  char buffer[12];
  memcpy(buffer, &point[0], sizeof(float));
  memcpy(buffer + 4, &point[1], sizeof(float));
  memcpy(buffer + 8, &point[2], sizeof(float));
  CHECK(file_writer->Write(buffer, 12));
}

std::unique_ptr<DynamicObjectsRemovalPointsProcessor> DynamicObjectsRemovalPointsProcessor::FromDictionary(
    const FileWriterFactory &file_writer_factory,
    common::LuaParameterDictionary *dictionary,
    PointsProcessor *next) {
  return absl::make_unique<DynamicObjectsRemovalPointsProcessor>(
      file_writer_factory(dictionary->GetString("filename")),
      dictionary->GetInt("r_segments"),
      dictionary->GetInt("theta_segments"),
      dictionary->GetInt("phi_segments"),
      dictionary->GetDouble("sensor_range_limit"),
      dictionary->GetInt("end_of_file"),
      dictionary->GetDouble("probability_reduction_factor"),
      dictionary->GetDouble("dynamic_object_probability_threshold"),
      dictionary->GetBool("open_view_deletion"),
      next);
}

DynamicObjectsRemovalPointsProcessor::DynamicObjectsRemovalPointsProcessor(std::unique_ptr<
    FileWriter> file_writer,
                                                                           const int r_segments,
                                                                           const int theta_segments,
                                                                           const int phi_segments,
                                                                           const double sensor_range_limit,
                                                                           const int end_of_file,
                                                                           const double probability_reduction_factor,
                                                                           const double dynamic_object_probability_threshold,
                                                                           const bool open_view_deletion,
                                                                           PointsProcessor *next)
    : r_segments_(r_segments),
      theta_segments_(theta_segments),
      phi_segments_(phi_segments),
      end_of_file_(end_of_file),
      sensor_range_limit_(sensor_range_limit),
      probability_reduction_factor_(probability_reduction_factor),
      dynamic_object_probability_threshold_(dynamic_object_probability_threshold),
      open_view_deletion_(open_view_deletion),
      next_(next),
      file_(std::move(file_writer)) {
  LOG(INFO) << "Initialized Dynamic objects removal filter with:\n" <<
            "r_segments:                            " << r_segments_ << "\n" <<
            "theta_segments:                        " << theta_segments_ << "\n" <<
            "phi_segments:                          " << phi_segments_ << "\n" <<
            "sensor_range_limit:                    " << sensor_range_limit_ << "\n" <<
            "end_of_file:                           " << end_of_file_ << "\n" <<
            "probability_reduction_factor:          " << probability_reduction_factor_ << "\n" <<
            "dynamic_object_probability_threshold:  " << dynamic_object_probability_threshold_
            << "\n" <<
            "open_view_deletion:                    " << open_view_deletion_;

  sensor_height_adjustment_ = transform::Rigid3<float>::Translation(Eigen::Vector3f(0, 0, 0));
  // Initialize max range for scan batch
  scan_batch_max_range_ = static_cast<uint16_t>(r_segments_);
}

void DynamicObjectsRemovalPointsProcessor::Process(std::unique_ptr<PointsBatch> batch) {
  // For debugging: sleep at first iteration
//  if (map_.empty()) {
//    std::this_thread::sleep_for(std::chrono::seconds(10));
//  }

  switch (run_state_) {
    case RunState::kInitialRun:LOG(INFO) << "Iteration: " << list_of_batches_.size() + 1
                                         << "\tBatch points: " << batch->points.size();
//      LOG(INFO) << "Batch origin:      x: " << batch->origin.x() << "\ty: " << batch->origin.y() << "\tz: " << batch->origin.z();
//      LOG(INFO) << "Batch transformation: " << batch->sensor_to_map.DebugString();

      // Copies the vector of sensor::RangeFinderPoint to a vector of sensor::TimedRangeFinderPoint
      // that uses the 4th attribute time as probability
      initialize_probabilities(*batch);

//      if (list_of_batches_.size() == end_of_file_-1) {
//        std::vector<std::string> comments;
//        WriteBinaryPlyHeader(false, false, comments, 11760, file_.get());
//        for (size_t i = 0; i < batch->points.size(); ++i) {
//          WriteBinaryPlyPointCoordinate(batch->sensor_to_map * batch->points[i].position,
//                                        file_.get());
//        }
//        WriteBinaryPlyHeader(false, false, comments, batch->points.size(),
//                             file_.get());
//      }

      // Create wedge for global map and current scan. Only if this isn't the first sca
      if (!map_.empty()) {
        // Create wedges
        wedge_map_t scan_wedge_map =
            create_wedge_map(sensor::TransformTimedPointCloud(batch->points_with_probabilities,
                                                              sensor_height_adjustment_), true);
        wedge_map_t global_wedge_map =
            create_wedge_map(/*sensor::TransformPointCloud(*/map_/*, batch->sensor_to_map.inverse())*/,
                                                             false);

        LOG(INFO) << "Scan wedge map size: " << scan_wedge_map.size() << "\tGlobal wedge map size: "
                  << global_wedge_map.size();

        // Test writing of points
        if (list_of_batches_.size() == end_of_file_ - 1) {
          std::srand(std::time(nullptr));
          sphercial_wedge wedge;
          float r_step = sensor_range_limit_ / r_segments_;
          float r_min = 0.0f * r_step;
          float r_max = 5.0f;//r_min + r_step;
          float theta_step = M_PIf / theta_segments_;
          float theta_min = 14.0f * theta_step;
          float theta_max = theta_min + theta_step;
          float phi_step = (2.0f * M_PIf) / phi_segments_;
          float phi_min = 16.0f * phi_step;
          float phi_max = phi_min + phi_step;

          for (int i = 0; i < 50 * 1000; ++i) {
            float r = r_min
                + static_cast<float>(rand()) / (static_cast <float> (RAND_MAX / (r_max - r_min)));
            float theta = theta_min + static_cast<float>(rand())
                / (static_cast <float> (RAND_MAX / (theta_max - theta_min)));
            float phi = phi_min + static_cast<float>(rand())
                / (static_cast <float> (RAND_MAX / (phi_max - phi_min)));
            sensor::TimedRangefinderPoint coords;
            coords.position = polar_to_cartesian(r, theta, phi);
            wedge.wedge_points.push_back(coords);
          }

          std::vector<std::string> comments;

          WriteBinaryPlyHeader(false, false, comments, 0, file_.get());
          /*for (size_t i = 0; i < batch->points.size(); ++i) {
            WriteBinaryPlyPointCoordinate(batch->sensor_to_map * batch->points[i].position, file_.get());
          }
          WriteBinaryPlyHeader(false, false, comments, batch->points.size(),
                               file_.get());*/
          for (size_t i = 0; i < wedge.wedge_points.size(); ++i) {
            WriteBinaryPlyPointCoordinate(wedge.wedge_points[i].position, file_.get());
          }
          WriteBinaryPlyHeader(false, false, comments, 50 * 1000,
                               file_.get());
          /*for (size_t i = 0; i < batch->points.size(); ++i) {
            WriteBinaryPlyPointCoordinate(batch->points[i].position, file_.get());
          }
          WriteBinaryPlyHeader(false, false, comments, batch->points.size(),
                               file_.get());*/
          /*for (size_t i = 0; i < map_.size(); ++i) {
            WriteBinaryPlyPointCoordinate(map_[i].position, file_.get());
          }
          WriteBinaryPlyHeader(false, false, comments, map_.size(),
                               file_.get());*/
          /*size_t num_to_write = 0;
          for (int new_r = 0; new_r <= r_segments_; ++new_r) {
            wedge_key_t new_key = std::make_tuple(new_r, 12, 0);

            auto search = global_wedge_map.find(new_key);
            if (search != global_wedge_map.end()) {
              // Wedge exists
              num_to_write += search->second.wedge_points.size();
              for (int i = 0; i < search->second.wedge_points.size(); ++i) {
                WriteBinaryPlyPointCoordinate(search->second.wedge_points[i].position, file_.get());
              }
            }
          }
          WriteBinaryPlyHeader(false, false, comments, num_to_write,
                               file_.get());*/
          CHECK(file_->Close()) << "Closing PLY file_writer failed.";
        }

        // Dynamic objects detection
        std::vector<wedge_key_t> keys_to_lower;
        size_t total_number_removed_points, total_to_be_lowered, already_lowered;

        total_number_removed_points = 0;
        total_to_be_lowered = 0;
        already_lowered = 0;

        // Detection of points of type 2 (delete map points in front of current detection points)
        std::unordered_map<std::pair<uint16_t, uint16_t>, int, key_hash_pair, key_equal_pair>
            scan_wedge_map_cardinalities;

        for (uint16_t theta_iter = 0; theta_iter < theta_segments_; ++theta_iter) {
          for (uint16_t phi_iter = 0; phi_iter < phi_segments_; ++phi_iter) {
            // Iterate over all scan wedges with same theta and phi but increasing distance r starting
            // at 0 to determine wedge with greatest cardinality
            std::pair<int, int> max_cardinality = std::make_pair(-1, -1);

            for (uint16_t r_iter = 0; r_iter < scan_batch_max_range_; ++r_iter) {
              wedge_key_t new_key = std::make_tuple(r_iter, theta_iter, phi_iter);

              auto search = scan_wedge_map.find(new_key);
              if (search != scan_wedge_map.end()) {
                // Wedge exists
                // Cardinality check: find wedge with greatest cardinality
                if (max_cardinality.first < 0 || max_cardinality.second < 0 ||
                    max_cardinality.second < static_cast<int>(search->second.wedge_points.size())) {
                  max_cardinality = std::make_pair(r_iter, search->second.wedge_points.size());
                }
              }
            }

            scan_wedge_map_cardinalities[std::make_pair(theta_iter, phi_iter)] =
                max_cardinality.first;

            if (max_cardinality.first >= 0 && max_cardinality.first <= r_segments_
                && max_cardinality.second >= 0) {
              // TODO(bhirschel) maybe set a minimum number of detections to make it significant
              // Significant detection perceived. Check if dynamic object
              uint16_t r_scan_detection =
                  max_cardinality.first - 1; // TODO(bhirschel) try adding a little tolerance here

              for (uint16_t r_to_lower = 0; r_to_lower < r_scan_detection; ++r_to_lower) {
                wedge_key_t new_key = std::make_tuple(r_to_lower, theta_iter, phi_iter);
                keys_to_lower.push_back(new_key);

                // Remove from the global wedge map. Necessary for potential future iterations over this ray in this time segment
                //global_wedge_map.erase(new_key);

                // Instead we lower the probability of all points in this wedge
                for (auto &p : global_wedge_map[new_key].wedge_points) {
                  p.time -= static_cast<float>(probability_reduction_factor_);
                  total_to_be_lowered++;
                }
              }
            }
          }
        }

        //Detection of points of type 3 (delete map points with empty scan ray)
        if (open_view_deletion_) {
          for (auto &wedge : global_wedge_map) {
            wedge_key_t this_key;
            int scan_wedge_cardinality;
            this_key = wedge.first;
            scan_wedge_cardinality =
                scan_wedge_map_cardinalities[std::make_pair(std::get<0>(this_key),
                                                            std::get<1>(this_key))];

            if (scan_wedge_cardinality == -1) {
              keys_to_lower.push_back(this_key);

              // Lower the probability of all points in this wedge
              for (auto &p : wedge.second.wedge_points) {
                p.time -= static_cast<float>(probability_reduction_factor_);
                total_to_be_lowered++;
              }
            }
          }
        }

        // Remove the points from the global map and from all local batches
        // Remove from the global map
        map_.clear();
        for (auto &wedge : global_wedge_map) {
          for (auto &p : wedge.second.wedge_points) {
            if (p.time >= static_cast<float>(dynamic_object_probability_threshold_)) {
              map_.push_back(p);
            } else {
              // Point was not taken over since its probability is too low. Will be removed from the map and batches
              total_number_removed_points++;
            }
          }
        }
        // Remove from the list of batches
        // iterate the list of batches revere because it is observable that
        // the last batch often is the main contributor of an dynamic objects' remaining
        // spurious trail. Count the number of points from the global map and break the loop if
        // this number was removed in total for all the individual batches
        for (auto batch_iter = list_of_batches_.rbegin(); batch_iter != list_of_batches_.rend();
             ++batch_iter) {
          //transform::Rigid3<float> transformation = batch->sensor_to_map.inverse() * batch_iter->sensor_to_map;  // TODO(bhirschel) verify order of linked transformations
          transform::Rigid3<float> transformation =
              sensor_height_adjustment_; // Currently only testing sensor height adjustment
          //            LOG(INFO) << "Size before: " << batch_iter.points.size();
          //already_removed += remove_points_from_batch(keys_to_delete, *batch_iter, transformation);
          already_lowered += lower_prob_in_batch(keys_to_lower, *batch_iter, transformation);

          //            LOG(INFO) << "Size after: " << batch_iter.points.size();

          if (already_lowered >= total_to_be_lowered) {
            //LOG(INFO) << "Removal cancelled early";
            break;
          }
        }
        LOG(INFO) << "Total number of removed points: " << total_number_removed_points;
      }

      // Add the current batch to the list of batches for later sending
      list_of_batches_.push_back(*batch);

      // Add all points from the current scan to the full map
      // IMPORTANT: First clear the full map and add all points from the global wedge map since
      // there the dynamic points have been removed while they are still in map_ ! This is done at
      // the deletion step above
      for (auto &point : batch->points_with_probabilities) {
        sensor::TimedRangefinderPoint
            new_point = {sensor_height_adjustment_ * point.position, point.time};
        map_.push_back(new_point);
      }

      LOG(INFO) << "Total Map points: " << map_.size();
      break;
    case RunState::kSecondRun:auto this_batch = list_of_batches_[0];
      copy_points_to_batch(this_batch);
      LOG(INFO) << "Batch sent. Size: " << this_batch.points.size();
      next_->Process(std::make_unique<PointsBatch>(this_batch));
      list_of_batches_.erase(list_of_batches_.begin());
  }
}

PointsProcessor::FlushResult DynamicObjectsRemovalPointsProcessor::Flush() {
  LOG(INFO) << "Flushing dynamic_object_removal_points_processor";
  if (run_state_ == RunState::kInitialRun) {
    run_state_ = RunState::kSecondRun;
    return FlushResult::kRestartStream;
  } else {
    return next_->Flush();
  }
}

Eigen::Vector3f DynamicObjectsRemovalPointsProcessor::cartesian_to_polar(Eigen::Vector3f cart_coord) {
  Eigen::Vector3f polar_coord;

  polar_coord.x() = cart_coord.norm(); // represents r
  polar_coord.y() = acosf((cart_coord.z() / polar_coord.x())); // represents theta between 0 and pi
  polar_coord.z() =
      atan2f(cart_coord.y(), cart_coord.x()) + M_PIf; // represents phi between 0 and +2pi

  return polar_coord;
}

Eigen::Vector3f DynamicObjectsRemovalPointsProcessor::polar_to_cartesian(float r,
                                                                         float theta,
                                                                         float phi) {
  Eigen::Vector3f cart;

  cart.x() = r * sinf(theta) * cosf(phi - M_PIf);
  cart.y() = r * sinf(theta) * sinf(phi - M_PIf);
  cart.z() = r * cosf(theta);

  return cart;
}

uint16_t DynamicObjectsRemovalPointsProcessor::cantor_pairing(uint16_t a, uint16_t b) {
  return ((a + b) * (a + b + 1)) / 2 + b;
}

DynamicObjectsRemovalPointsProcessor::wedge_key_t DynamicObjectsRemovalPointsProcessor::get_interval_segment(
    Eigen::Vector3f p) const {
  float r, theta, phi;
  uint16_t r_seg, theta_seg, phi_seg;

  r = p.x();
  theta = static_cast<float>(fmod(p.y(), M_PIf));
  phi = static_cast<float>(fmod(p.z(), 2.0f * M_PIf));

  // Convert into positive space from 0 to pi or 0 to 2pi, respectively
  theta = theta < 0 ? theta + M_PIf : theta;
  phi = phi < 0 ? phi + 2.0f * M_PIf : phi;

  // Get index of the interval segment it belongs to
  r_seg = static_cast<uint16_t>(floorf(r / (sensor_range_limit_ / r_segments_)));
  theta_seg = static_cast<uint16_t>(floorf(theta / (M_PIf / theta_segments_)));
  phi_seg = static_cast<uint16_t>(floorf(phi / ((2.0f * M_PIf) / phi_segments_)));

  return std::make_tuple(r_seg, theta_seg, phi_seg);
}

DynamicObjectsRemovalPointsProcessor::wedge_map_t DynamicObjectsRemovalPointsProcessor::create_wedge_map(
    const sensor::TimedPointCloud &cloud, bool is_scan_batch) {
  wedge_map_t wedge_map;

  for (auto &p : cloud) {
    Eigen::Vector3f polar = cartesian_to_polar(p.position);

    // Skip if global wedge map and distance is greater than the sensor range limit
    if (!is_scan_batch && polar.x() > sensor_range_limit_) {
      continue;
    }

    wedge_key_t key = get_interval_segment(polar);
    auto search = wedge_map.find(key);
    if (search == wedge_map.end()) {
      // No such element existed before
      sphercial_wedge wedge;
      wedge.wedge_points.push_back(p);
      wedge_map[key] = wedge;
    } else {
      // This wedge already exists, add point to the pointcloud
      search->second.wedge_points.push_back(p);
    }

    if (is_scan_batch && polar.x() > sensor_range_limit_) {
      scan_batch_max_range_ = std::get<0>(key);
    }

    // Test of cartesian to polar and vice versa
    /*Eigen::Vector3f rev = polar_to_cartesian(polar.x(), polar.y(), polar.z());
    LOG(INFO) << "ORG: x: " << p.position.x() << "\ty: " << p.position.y() << "\tz: " << p.position.z();
    LOG(INFO) << "POL: r: " << polar.x() << "\tt: " << polar.y() << "\tp: " << polar.z();
    LOG(INFO) << "REV: x: " << rev.x() << "\ty: " << rev.y() << "\tz: " << rev.z();*/

    // Test of key
//    LOG(INFO) << "ORG: x: " << p.position.x() << "\ty: " << p.position.y() << "\tz: " << p.position.z();
//    LOG(INFO) << "POL: r: " << polar.x() << "\tt: " << polar.y() << "\tp: " << polar.z();
//    LOG(INFO) << "KEY: r: " << std::get<0>(key) <<"\tt: " << std::get<1>(key) << "\tp: " << std::get<2>(key);
  }

  return wedge_map;
}

size_t DynamicObjectsRemovalPointsProcessor::lower_prob_in_batch(std::vector<wedge_key_t> keys_to_lower,
                                                                 PointsBatch &batch,
                                                                 const transform::Rigid3<float> &transformation) {
  absl::flat_hash_set<int> to_remove;
  size_t total_lowered = 0;

  for (size_t i = 0; i < batch.points_with_probabilities.size(); ++i) {
    wedge_key_t local_key = get_interval_segment(cartesian_to_polar(
        transformation * batch.points_with_probabilities[i].position));
    if (std::find(keys_to_lower.begin(), keys_to_lower.end(), local_key) != keys_to_lower.end()) {
      batch.points_with_probabilities[i].time -= static_cast<float>(probability_reduction_factor_);
      total_lowered++;

      if (batch.points_with_probabilities[i].time
          < static_cast<float>(dynamic_object_probability_threshold_)) {
        to_remove.insert(i);
      }
    }
  }

  if (!to_remove.empty()) {
    RemoveTimedPoints(to_remove, &batch);
  }

  return total_lowered;
}

void DynamicObjectsRemovalPointsProcessor::initialize_probabilities(PointsBatch &batch) {
  batch.points_with_probabilities.clear();
  batch.points.reserve(batch.points.size());

  for (auto &p : batch.points) {
    sensor::TimedRangefinderPoint new_point = {p.position, 1.0};

    batch.points_with_probabilities.push_back(new_point);
  }

  batch.points.clear();
}

void DynamicObjectsRemovalPointsProcessor::RemoveTimedPoints(const absl::flat_hash_set<int> &to_remove,
                                                             PointsBatch *batch) {
  const size_t new_num_points = batch->points_with_probabilities.size() - to_remove.size();
  sensor::TimedPointCloud points;
  points.reserve(new_num_points);
  std::vector<float> intensities;
  if (!batch->intensities.empty()) {
    intensities.reserve(new_num_points);
  }
  std::vector<FloatColor> colors;
  if (!batch->colors.empty()) {
    colors.reserve(new_num_points);
  }

  for (size_t i = 0; i < batch->points_with_probabilities.size(); ++i) {
    if (to_remove.count(static_cast<int>(i)) == 1) {
      continue;
    }
    points.push_back(batch->points_with_probabilities[i]);
    if (!batch->colors.empty()) {
      colors.push_back(batch->colors[i]);
    }
    if (!batch->intensities.empty()) {
      intensities.push_back(batch->intensities[i]);
    }
  }
  batch->points_with_probabilities = std::move(points);
  batch->intensities = std::move(intensities);
  batch->colors = std::move(colors);
}

void DynamicObjectsRemovalPointsProcessor::copy_points_to_batch(PointsBatch &batch) {
  batch.points.reserve(batch.points_with_probabilities.size());

  for (auto &point : batch.points_with_probabilities) {
    sensor::RangefinderPoint new_point = {point.position};

    batch.points.push_back(new_point);
  }

  batch.points_with_probabilities.clear();
}
}
}
